# E1-S3: Create useProjects Composable

## Story
**As a** frontend developer building the DevPulse dashboard
**I want** a Vue composable that manages project, session, and dev log data via WebSocket and REST
**So that** all dashboard tabs have reactive, real-time data without duplicating connection logic

## Status
- **Epic**: Core Dashboard Foundation
- **Priority**: P0-Critical
- **Points**: 3
- **Sprint**: 1
- **Dependencies**: E1-S2 (needs Project, Session, DevLog types)

## Acceptance Criteria
- [ ] AC1: Composable connects to the existing WebSocket at `ws://localhost:4000/stream` (via `WS_URL` from `apps/client/src/config.ts`)
- [ ] AC2: When a `type: 'projects'` message arrives on WebSocket, the reactive `projects` ref is updated with the full `Project[]` array
- [ ] AC3: When a `type: 'sessions'` message arrives on WebSocket, the reactive `sessions` ref is updated with the full `Session[]` array
- [ ] AC4: On mount, composable fetches dev logs via `GET /api/devlogs?limit=50` and populates the reactive `devLogs` ref
- [ ] AC5: Dev logs are re-fetched every 30 seconds via `setInterval` (cleaned up on unmount)
- [ ] AC6: Composable returns `{ projects, sessions, devLogs }` as `Ref<Project[]>`, `Ref<Session[]>`, `Ref<DevLog[]>`
- [ ] AC7: Composable reuses the existing WebSocket connection from `useWebSocket` rather than opening a second connection

## Technical Notes

### Architecture Decision: Extend useWebSocket vs New Composable
The existing `useWebSocket.ts` (lines 1-99) only handles `'initial'` and `'event'` message types and ignores `'projects'`/`'sessions'` messages. There are two approaches:

**Option A (Recommended): Extend useWebSocket** - Add handling for `'projects'` and `'sessions'` message types inside the existing `ws.onmessage` handler (line 26). This avoids a second WebSocket connection and keeps all WS logic centralized. Then create `useProjects` as a thin wrapper that calls `useWebSocket` and adds the REST polling for dev logs.

**Option B: Separate composable with shared WS** - Create `useProjects` as standalone, but this requires either a second WS connection (wasteful) or a shared event bus pattern.

### Implementation Plan (Option A)

**Step 1: Modify `useWebSocket.ts`** to also expose `projects` and `sessions` refs:
- Add `const projects = ref<Project[]>([])` and `const sessions = ref<Session[]>([])` (import types from `../types`)
- In `ws.onmessage` (line 26), add handling after the existing `if/else if` blocks:
  ```typescript
  } else if (message.type === 'projects') {
    projects.value = Array.isArray(message.data) ? message.data as Project[] : [];
  } else if (message.type === 'sessions') {
    sessions.value = Array.isArray(message.data) ? message.data as Session[] : [];
  }
  ```
- Return `projects` and `sessions` alongside existing `events`, `isConnected`, `error`, `clearEvents`

**Step 2: Create `useProjects.ts`** as a composable that:
- Imports `useWebSocket` (or receives its return value as a parameter to avoid duplicate connections)
- Actually, since `useWebSocket` is already called in `App.vue` line 154, `useProjects` should NOT call `useWebSocket` again. Instead, `useProjects` should accept `projects` and `sessions` refs as parameters (injected from App.vue) and add the dev log polling logic.

**Revised approach**: `useProjects` accepts `projects` and `sessions` refs from the parent (from `useWebSocket`) and manages `devLogs` independently via REST polling.

```typescript
export function useProjects(projects: Ref<Project[]>, sessions: Ref<Session[]>) {
  const devLogs = ref<DevLog[]>([]);
  // REST polling for dev logs
  // Returns { projects, sessions, devLogs }
}
```

### REST Endpoint
- `GET /api/devlogs?limit=50` (server `index.ts` lines 220-229)
- Returns `DevLog[]` directly (no wrapper object)
- Optional `project` query param for filtering: `GET /api/devlogs?project=MyApp&limit=50`

### Config
Use `API_BASE_URL` from `apps/client/src/config.ts` (line 6) for REST calls:
```typescript
import { API_BASE_URL } from '../config';
const response = await fetch(`${API_BASE_URL}/api/devlogs?limit=50`);
```

### Cleanup
- `clearInterval` the 30s polling timer in `onUnmounted`
- The WebSocket cleanup is handled by `useWebSocket` itself

## Tasks
- [ ] Task 1: Modify `apps/client/src/composables/useWebSocket.ts` to add `projects` and `sessions` refs and handle `type: 'projects'` and `type: 'sessions'` WebSocket messages (add after line 41)
- [ ] Task 2: Update `useWebSocket` return object (line 93-98) to include `projects` and `sessions` refs
- [ ] Task 3: Create `apps/client/src/composables/useProjects.ts` that accepts `projects` and `sessions` refs as parameters
- [ ] Task 4: Implement `fetchDevLogs()` function using `fetch()` against `${API_BASE_URL}/api/devlogs?limit=50`
- [ ] Task 5: Set up 30-second `setInterval` polling for dev logs on mount, with cleanup on unmount
- [ ] Task 6: Return `{ projects, sessions, devLogs }` from the composable

## Files to Create/Modify
| File | Action | Description |
|------|--------|-------------|
| `apps/client/src/composables/useWebSocket.ts` | Modify | Add projects/sessions refs, handle 'projects'/'sessions' WS messages |
| `apps/client/src/composables/useProjects.ts` | Create | New composable for dev log REST polling, wraps project/session data |

## Testing
- [ ] Test 1: `useWebSocket` returns `projects` and `sessions` refs in its return object
- [ ] Test 2: When WS receives `{type: 'projects', data: [...]}`, `projects.value` is updated
- [ ] Test 3: When WS receives `{type: 'sessions', data: [...]}`, `sessions.value` is updated
- [ ] Test 4: `useProjects` fetches dev logs on mount from `/api/devlogs?limit=50`
- [ ] Test 5: Dev log polling runs every 30 seconds and updates `devLogs` ref
- [ ] Test 6: Polling interval is cleaned up when component unmounts

## Definition of Done
- [ ] Code compiles without errors (`cd apps/client && bun run build`)
- [ ] All acceptance criteria met
- [ ] No TypeScript errors
- [ ] useWebSocket backward compatible (existing callers still work)
- [ ] No duplicate WebSocket connections opened
- [ ] REST polling cleaned up on unmount
