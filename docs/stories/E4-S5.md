# E4-S5: Cross-Project Dependency Awareness

## Story
**As a** developer running AI agents across multiple related projects simultaneously
**I want** DevPulse to detect when agents in different projects are referencing the same files or packages
**So that** I can spot potential conflicts early (e.g., two agents editing a shared config) and understand cross-project dependencies

## Status
- **Epic**: Multi-Agent Intelligence
- **Priority**: P2-Medium
- **Points**: 8
- **Sprint**: 9
- **Dependencies**: None (file paths already present in PostToolUse event payloads)

## Acceptance Criteria
- [ ] AC1: DevPulse tracks file paths referenced by Read/Write/Edit tool events across all active sessions and projects
- [ ] AC2: When two or more agents in different projects reference the same file path within a configurable time window (default: 30 minutes), a conflict alert is generated
- [ ] AC3: The conflict alert shows: the shared file path, which projects/agents are referencing it, and whether it's a read or write operation
- [ ] AC4: Write-write conflicts (two agents writing to the same file) are flagged as high severity; read-write conflicts are medium; read-read are informational only
- [ ] AC5: A "Dependencies" section in the dashboard shows a summary of all currently detected cross-project file references, sorted by conflict severity
- [ ] AC6: The conflict detection also identifies shared package dependencies by parsing `package.json` paths and flagging when agents in different projects modify package files
- [ ] AC7: Alerts are dismissible and do not re-trigger for the same file+agents combination within the time window

## Technical Notes

### File Access Tracking
Extract file paths from PostToolUse events where `tool_name` is Read, Write, Edit, or Glob:
- Read: `payload.tool_input.file_path`
- Write: `payload.tool_input.file_path`
- Edit: `payload.tool_input.file_path`

Store in a lightweight tracking table:

```sql
CREATE TABLE IF NOT EXISTS file_access_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  file_path TEXT NOT NULL,
  project_name TEXT NOT NULL,
  session_id TEXT NOT NULL,
  source_app TEXT NOT NULL,
  access_type TEXT NOT NULL,  -- 'read' | 'write'
  timestamp INTEGER NOT NULL
)
```

Index on `file_path` and `timestamp` for efficient conflict queries.

### Conflict Detection Algorithm
Run periodically (every 10 seconds) or on each new file access event:
1. Query `file_access_log` for entries within the time window grouped by `file_path`
2. For each file_path, check if entries span multiple distinct `project_name` values
3. If yes, determine severity:
   - High: multiple projects have 'write' access
   - Medium: one project writes, another reads
   - Low: multiple projects read only (informational)
4. Generate conflict record if not already active for this file+projects combination

### Conflict Data Structure
```typescript
interface FileConflict {
  id: string;
  file_path: string;
  severity: 'high' | 'medium' | 'low';
  projects: Array<{
    project_name: string;
    agent_id: string;      // source_app:session_id
    access_type: 'read' | 'write';
    last_access: number;
  }>;
  detected_at: number;
  dismissed: boolean;
}
```

### Normalising File Paths
File paths from different project cwds may reference the same file differently (absolute vs relative). Normalize by:
1. Store absolute paths as-is
2. For conflict detection, also check filename-only matches for common config files: `package.json`, `tsconfig.json`, `.env`, `schema.prisma`
3. Detect shared monorepo paths: if two projects share a common ancestor directory and reference the same file relative to that ancestor

### Package Dependency Detection
When a file path matches `*/package.json` or `*/bun.lockb` or `*/pnpm-lock.yaml`, flag as a package dependency modification. These are particularly important for monorepos where shared packages affect multiple projects.

### API and WebSocket
- `GET /api/conflicts` - returns active (non-dismissed) conflicts
- Broadcast conflicts via WebSocket as `{ type: 'conflicts', data: FileConflict[] }`
- `POST /api/conflicts/:id/dismiss` - mark a conflict as dismissed

### Client Component
Display conflicts in a dedicated panel or section. High-severity conflicts could also trigger a desktop notification (if E3-S4 notification system is available).

## Tasks
- [ ] Task 1: Create `file_access_log` table in `apps/server/src/enricher.ts` `initEnricher()`:
  - Schema as defined above
  - Indexes on `file_path`, `timestamp`, and `project_name`
  - Periodic cleanup: delete entries older than 24 hours
- [ ] Task 2: Create `apps/server/src/conflicts.ts` with:
  - `trackFileAccess(filePath: string, projectName: string, sessionId: string, sourceApp: string, accessType: string): void` - insert into file_access_log
  - `detectConflicts(windowMinutes: number): FileConflict[]` - query for cross-project file access within window
  - `getActiveConflicts(): FileConflict[]` - return non-dismissed conflicts
  - `dismissConflict(id: string): void` - mark as dismissed
  - `normalizeFilePath(path: string): string` - normalize for comparison
  - `isPackageFile(path: string): boolean` - check if path is a package dependency file
- [ ] Task 3: Add `FileConflict` interface to `apps/server/src/types.ts`
- [ ] Task 4: Update `enrichEvent()` in `apps/server/src/enricher.ts`:
  - For PostToolUse events with tool_name Read/Write/Edit, extract file_path and call `trackFileAccess()`
  - Map tool_name to access_type: Write/Edit -> 'write', Read -> 'read'
  - After tracking, call `detectConflicts()` and broadcast if new conflicts found
- [ ] Task 5: Add API routes to `apps/server/src/index.ts`:
  - `GET /api/conflicts` -> `getActiveConflicts()`
  - `POST /api/conflicts/:id/dismiss` -> `dismissConflict(id)`
- [ ] Task 6: Add conflict broadcast to WebSocket in `apps/server/src/index.ts`:
  - New message type `{ type: 'conflicts', data: FileConflict[] }`
  - Send on connection open and when new conflicts detected
- [ ] Task 7: Create `apps/client/src/components/ConflictPanel.vue`:
  - List of active conflicts, sorted by severity (high first)
  - Each conflict card shows: file path, severity badge (red/yellow/blue), involved projects and agents, access types, time detected
  - Dismiss button per conflict
  - Empty state when no conflicts
  - High-severity conflicts have a pulsing red indicator
- [ ] Task 8: Add `FileConflict` type to `apps/client/src/types.ts` and extend `WebSocketMessage` to include `'conflicts'`
- [ ] Task 9: Update `useWebSocket.ts` to handle `'conflicts'` message type and expose `conflicts` ref
- [ ] Task 10: Integrate `ConflictPanel.vue` into `apps/client/src/App.vue`:
  - Add "Conflicts" indicator in header (show count badge if active conflicts exist)
  - Toggle panel visibility on click
  - Show red badge count for high-severity conflicts

## Files to Create/Modify
| File | Action | Description |
|------|--------|-------------|
| `apps/server/src/conflicts.ts` | Create | File access tracking and conflict detection |
| `apps/server/src/types.ts` | Modify | Add `FileConflict` interface |
| `apps/server/src/enricher.ts` | Modify | Add `file_access_log` table, call file tracking for Read/Write/Edit events |
| `apps/server/src/index.ts` | Modify | Add conflicts API routes and WebSocket broadcast |
| `apps/client/src/components/ConflictPanel.vue` | Create | Conflict list with severity badges and dismiss |
| `apps/client/src/types.ts` | Modify | Add `FileConflict` type, extend `WebSocketMessage` |
| `apps/client/src/composables/useWebSocket.ts` | Modify | Handle `'conflicts'` message type |
| `apps/client/src/App.vue` | Modify | Add conflicts indicator and panel toggle |

## Testing
- [ ] Test 1: Unit test `conflicts.ts` - `trackFileAccess()` inserts record correctly
- [ ] Test 2: Unit test `conflicts.ts` - `detectConflicts()` returns empty when all accesses are from same project
- [ ] Test 3: Unit test `conflicts.ts` - `detectConflicts()` returns high severity when two projects write to same file
- [ ] Test 4: Unit test `conflicts.ts` - `detectConflicts()` returns medium severity when one project reads and another writes same file
- [ ] Test 5: Unit test `conflicts.ts` - `detectConflicts()` ignores entries outside the time window
- [ ] Test 6: Unit test `conflicts.ts` - `normalizeFilePath()` handles absolute paths correctly
- [ ] Test 7: Unit test `conflicts.ts` - `isPackageFile()` returns true for package.json, bun.lockb, pnpm-lock.yaml
- [ ] Test 8: Integration test - POST Write events from two different projects referencing same file, GET /api/conflicts returns one conflict
- [ ] Test 9: Integration test - POST /api/conflicts/:id/dismiss, verify conflict no longer in active list

## Definition of Done
- [ ] Code compiles without errors
- [ ] All acceptance criteria met
- [ ] No TypeScript errors
- [ ] Responsive on mobile and desktop
- [ ] Dark/light theme support works
- [ ] Conflict detection runs efficiently (no full table scans)
- [ ] Old file access entries cleaned up automatically (>24 hours)
- [ ] Dismissed conflicts do not re-appear for the same file+agents within time window
- [ ] High-severity conflicts are visually prominent
