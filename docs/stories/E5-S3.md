# E5-S3: Smart Alerts & Anomaly Detection

## Story
**As a** developer managing multiple concurrent Claude Code sessions
**I want** automatic alerts when agents get stuck, produce excessive errors, or exhibit anomalous behavior
**So that** I can intervene quickly before problems compound and wasted effort accumulates

## Status
- **Epic**: Developer Experience & Productivity
- **Priority**: P1-High
- **Points**: 5
- **Sprint**: 5
- **Dependencies**: None (uses existing events table and enricher)

## Acceptance Criteria
- [ ] AC1: An alert banner appears at the top of the dashboard when a stuck agent is detected (no events for >5 minutes while session status is 'active')
- [ ] AC2: An alert fires when excessive file writes occur (>50 Write or Edit tool events from a single session within 1 minute)
- [ ] AC3: An alert fires when repeated failures occur (>5 PostToolUseFailure events from a single session within 2 minutes)
- [ ] AC4: Each alert displays: severity (warning/critical), affected agent identifier (source_app:session_id truncated to 8 chars), description, and time detected
- [ ] AC5: Alerts can be dismissed individually by clicking an X button; dismissed alerts do not reappear for the same condition within 10 minutes
- [ ] AC6: A small alert count badge appears in the App.vue header when there are active (undismissed) alerts
- [ ] AC7: Alert thresholds are configurable through a settings object in the composable (not hardcoded)
- [ ] AC8: Alerts are checked server-side on a polling interval and broadcast via WebSocket as a new message type `alerts`

## Technical Notes

### Architecture
Two-part implementation:
1. **Server-side detection** (`apps/server/src/alerts.ts`): runs checks on an interval (every 30 seconds), queries the database for anomalous patterns, broadcasts alerts via WebSocket
2. **Client-side display** (`AlertBanner.vue` + `useAlerts.ts`): receives alerts via WebSocket, manages dismiss state in memory

### Server: Alert Detection Logic

New file `apps/server/src/alerts.ts`:
```typescript
interface Alert {
  id: string;              // Unique: `${type}-${sessionId}-${sourceApp}-${timestamp}`
  type: 'stuck_agent' | 'excessive_writes' | 'repeated_failures';
  severity: 'warning' | 'critical';
  sessionId: string;
  sourceApp: string;
  agentLabel: string;      // "source_app:session_id" (truncated)
  message: string;
  detectedAt: number;
}
```

Detection queries:
- **Stuck agent**: Sessions with `status = 'active'` and `last_event_at < NOW - 5min`. Severity: warning.
- **Excessive writes**: `SELECT session_id, source_app, COUNT(*) as cnt FROM events WHERE hook_event_type = 'PostToolUse' AND payload LIKE '%"tool_name":"Write"%' OR payload LIKE '%"tool_name":"Edit"%' AND timestamp > NOW - 60000 GROUP BY session_id, source_app HAVING cnt > 50`. Severity: critical.
- **Repeated failures**: `SELECT session_id, source_app, COUNT(*) as cnt FROM events WHERE hook_event_type = 'PostToolUseFailure' AND timestamp > NOW - 120000 GROUP BY session_id, source_app HAVING cnt > 5`. Severity: warning (>5), critical (>10).

### Server Integration
- In `apps/server/src/index.ts`, import `checkAlerts()` from alerts.ts
- Run `checkAlerts()` every 30 seconds alongside the existing `markIdleSessions()` interval
- Broadcast alerts to WebSocket clients as `{ type: 'alerts', data: Alert[] }`

### Client: WebSocket Extension
- Extend `useWebSocket.ts` to handle the new `alerts` message type, exposing an `alerts` ref
- Or create a separate `useAlerts.ts` composable that listens to the WebSocket alerts channel

### Client: AlertBanner Component
- Renders as a fixed/sticky bar at the top of the content area (below header, above LivePulseChart)
- Uses `var(--theme-accent-warning)` for warnings and `var(--theme-accent-error)` for critical alerts
- Dismissed alert IDs stored in a reactive `Set<string>` with a TTL map for 10-minute suppression

### Configurable Thresholds
```typescript
interface AlertThresholds {
  stuckAgentMinutes: number;     // default: 5
  excessiveWritesCount: number;  // default: 50
  excessiveWritesWindowMs: number; // default: 60000
  repeatedFailuresCount: number; // default: 5
  repeatedFailuresWindowMs: number; // default: 120000
}
```

## Tasks
- [ ] Task 1: Create `apps/server/src/alerts.ts` with `Alert` interface, `AlertThresholds` config, and `checkAlerts(db)` function implementing stuck agent, excessive writes, and repeated failures detection queries
- [ ] Task 2: Modify `apps/server/src/index.ts` to import and call `checkAlerts()` on a 30-second interval, broadcast results to WebSocket clients as `{ type: 'alerts', data: Alert[] }`
- [ ] Task 3: Modify `apps/client/src/composables/useWebSocket.ts` to handle the `alerts` message type, exposing an `alerts` reactive ref of `Alert[]`
- [ ] Task 4: Create `apps/client/src/composables/useAlerts.ts` composable managing dismiss state (Set of dismissed alert IDs), 10-minute suppression TTL, and `activeAlerts` computed that filters out dismissed alerts
- [ ] Task 5: Create `apps/client/src/components/AlertBanner.vue` displaying active alerts with severity icon, agent label, message, timestamp, and dismiss button
- [ ] Task 6: Modify `apps/client/src/App.vue` to import AlertBanner, render it between the header and LivePulseChart, pass alerts from WebSocket, and add an alert count badge in the header

## Files to Create/Modify
| File | Action | Description |
|------|--------|-------------|
| `apps/server/src/alerts.ts` | Create | Alert detection logic: stuck agents, excessive writes, repeated failures |
| `apps/server/src/index.ts` | Modify | Import alerts module, run detection on interval, broadcast via WebSocket |
| `apps/client/src/composables/useWebSocket.ts` | Modify | Handle `alerts` WebSocket message type, expose `alerts` ref |
| `apps/client/src/composables/useAlerts.ts` | Create | Alert dismiss state, TTL suppression, activeAlerts computed |
| `apps/client/src/components/AlertBanner.vue` | Create | Alert banner UI with severity styling and dismiss |
| `apps/client/src/App.vue` | Modify | Render AlertBanner, add header alert count badge |

## Testing
- [ ] Test 1: `checkAlerts()` returns a stuck_agent alert when a session has `status='active'` and `last_event_at` older than 5 minutes
- [ ] Test 2: `checkAlerts()` returns an excessive_writes alert when >50 Write/Edit events exist within 1 minute for a session
- [ ] Test 3: `checkAlerts()` returns a repeated_failures alert when >5 PostToolUseFailure events exist within 2 minutes for a session
- [ ] Test 4: AlertBanner renders warning alerts with amber styling and critical alerts with red styling
- [ ] Test 5: Dismissing an alert removes it from the display; the same alert ID does not reappear for 10 minutes
- [ ] Test 6: Alert count badge in header shows correct count of undismissed alerts

## Definition of Done
- [ ] Code compiles without errors (both server and client)
- [ ] All acceptance criteria met
- [ ] No TypeScript errors
- [ ] Alert detection runs without blocking the event processing pipeline
- [ ] Dark/light theme support works via CSS variables
- [ ] Alerts are non-intrusive (dismissable, not modal)
